// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stealth-api-v2.0.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace QuantGate.API.Proto.Stealth {

  /// <summary>Holder for reflection information generated from stealth-api-v2.0.proto</summary>
  internal static partial class StealthApiV20Reflection {

    #region Descriptor
    /// <summary>File descriptor for stealth-api-v2.0.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static StealthApiV20Reflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZzdGVhbHRoLWFwaS12Mi4wLnByb3RvEgdzdGVhbHRoIlkKD1NlbnRpbWVu",
            "dFNwbGluZRIPCgdhdmVyYWdlGAEgASgREgkKAWkYAiABKA0SCQoBahgDIAEo",
            "DRIJCgF4GAQgASgREgkKAXkYBSABKBESCQoBehgGIAEoESKLAQoPU2VudGlt",
            "ZW50VXBkYXRlEhEKCXRpbWVzdGFtcBgBIAEoBBIpCgdsZW5ndGhzGAIgASgL",
            "Mhguc3RlYWx0aC5TZW50aW1lbnRTcGxpbmUSKAoGY29sb3JzGAMgASgLMhgu",
            "c3RlYWx0aC5TZW50aW1lbnRTcGxpbmUSEAoIaXNfZGlydHkYBCABKAgitQEK",
            "EUVxdWlsaWJyaXVtVXBkYXRlEhEKCXRpbWVzdGFtcBgBIAEoBBIZChFlcXVp",
            "bGlicml1bV9wcmljZRgCIAEoBBIQCghnYXBfc2l6ZRgDIAEoBBIMCgRoaWdo",
            "GAQgASgREgsKA2xvdxgFIAEoERIRCglwcm9qZWN0ZWQYBiABKBESDAoEYmlh",
            "cxgHIAEoERISCgpsYXN0X3ByaWNlGAggASgEEhAKCGlzX2RpcnR5GAkgASgI",
            "ItgBChBNdWx0aWZyYW1lVXBkYXRlEhEKCXRpbWVzdGFtcBgBIAEoBBINCgVt",
            "aW5fNRgCIAEoERIOCgZtaW5fMTAYAyABKBESDgoGbWluXzE1GAQgASgREg4K",
            "Bm1pbl8zMBgFIAEoERIOCgZtaW5fNDUYBiABKBESDgoGbWluXzYwGAcgASgR",
            "Eg8KB21pbl8xMjAYCCABKBESDwoHbWluXzE4MBgJIAEoERIPCgdtaW5fMjQw",
            "GAogASgREg0KBWRheV8xGAsgASgREhAKCGlzX2RpcnR5GAwgASgIIr4BCg1U",
            "cmlnZ2VyVXBkYXRlEhEKCXRpbWVzdGFtcBgBIAEoBBIMCgRiaWFzGAIgASgR",
            "EhIKCnBlcmNlcHRpb24YAyABKBESEQoJc2VudGltZW50GAQgASgREhIKCmNv",
            "bW1pdG1lbnQYBSABKBESGQoRZXF1aWxpYnJpdW1fcHJpY2UYBiABKAQSEAoI",
            "Z2FwX3NpemUYByABKAQSEgoKbGFzdF9wcmljZRgIIAEoBBIQCghpc19kaXJ0",
            "eRgJIAEoCCJHChFTaW5nbGVWYWx1ZVVwZGF0ZRIRCgl0aW1lc3RhbXAYASAB",
            "KAQSDQoFdmFsdWUYAiABKBESEAoIaXNfZGlydHkYAyABKAgipwMKDlN0cmF0",
            "ZWd5VXBkYXRlEhEKCXRpbWVzdGFtcBgBIAEoBBIWCg5lbnRyeV9wcm9ncmVz",
            "cxgCIAEoERIVCg1leGl0X3Byb2dyZXNzGAMgASgREicKBnNpZ25hbBgEIAEo",
            "DjIXLnN0ZWFsdGguU3RyYXRlZ3lTaWduYWwSGAoQcGVyY2VwdGlvbl9sZXZl",
            "bBgFIAEoDRIvChFwZXJjZXB0aW9uX3NpZ25hbBgGIAEoDjIULnN0ZWFsdGgu",
            "R2F1Z2VTaWduYWwSGAoQY29tbWl0bWVudF9sZXZlbBgHIAEoDRIvChFjb21t",
            "aXRtZW50X3NpZ25hbBgIIAEoDjIULnN0ZWFsdGguR2F1Z2VTaWduYWwSLgoQ",
            "c2VudGltZW50X3NpZ25hbBgJIAEoDjIULnN0ZWFsdGguR2F1Z2VTaWduYWwS",
            "MAoSZXF1aWxpYnJpdW1fc2lnbmFsGAogASgOMhQuc3RlYWx0aC5HYXVnZVNp",
            "Z25hbBIXCg9zZW50aW1lbnRfbGV2ZWwYCyABKA0SGQoRZXF1aWxpYnJpdW1f",
            "bGV2ZWwYDCABKA0iRwoRU2luZ2xlUHJpY2VVcGRhdGUSEQoJdGltZXN0YW1w",
            "GAEgASgEEg0KBXZhbHVlGAIgASgEEhAKCGlzX2RpcnR5GAMgASgIIrEBCglU",
            "aWNrVmFsdWUSDQoFc3RhcnQYASABKAESDAoEdGljaxgCIAEoARITCgtkZW5v",
            "bWluYXRvchgDIAEoDRIQCghkZWNpbWFscxgEIAEoERItCgZmb3JtYXQYBSAB",
            "KA4yHS5zdGVhbHRoLlRpY2tWYWx1ZS5UaWNrRm9ybWF0IjEKClRpY2tGb3Jt",
            "YXQSCwoHRGVjaW1hbBAAEgwKCEZyYWN0aW9uEAESCAoEVGljaxACIi8KDlRy",
            "YWRpbmdTZXNzaW9uEg0KBWNsb3NlGAEgASgREg4KBmxlbmd0aBgCIAEoESLv",
            "AwoQSW5zdHJ1bWVudFVwZGF0ZRIOCgZzeW1ib2wYASABKAkSEgoKdW5kZXJs",
            "eWluZxgCIAEoCRIQCghjdXJyZW5jeRgDIAEoCRIQCghleGNoYW5nZRgEIAEo",
            "CRIwCg9pbnN0cnVtZW50X3R5cGUYBSABKA4yFy5zdGVhbHRoLkluc3RydW1l",
            "bnRUeXBlEicKC3B1dF9vcl9jYWxsGAYgASgOMhIuc3RlYWx0aC5QdXRPckNh",
            "bGwSDgoGc3RyaWtlGAcgASgBEhMKC2V4cGlyeV9kYXRlGAggASgEEhIKCm11",
            "bHRpcGxpZXIYCSABKAESFAoMZGlzcGxheV9uYW1lGAogASgJEhEKCXRpbWVf",
            "em9uZRgLIAEoCRInCgt0aWNrX3ZhbHVlcxgMIAMoCzISLnN0ZWFsdGguVGlj",
            "a1ZhbHVlEjEKEHRyYWRpbmdfc2Vzc2lvbnMYDSADKAsyFy5zdGVhbHRoLlRy",
            "YWRpbmdTZXNzaW9uEkQKDmJyb2tlcl9zeW1ib2xzGA4gAygLMiwuc3RlYWx0",
            "aC5JbnN0cnVtZW50VXBkYXRlLkJyb2tlclN5bWJvbHNFbnRyeRo0ChJCcm9r",
            "ZXJTeW1ib2xzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4",
            "ASKkAQoSU3ltYm9sU2VhcmNoUmVzdWx0Eg4KBnN5bWJvbBgBIAEoCRISCgp1",
            "bmRlcmx5aW5nGAIgASgJEhAKCGN1cnJlbmN5GAMgASgJEjAKD2luc3RydW1l",
            "bnRfdHlwZRgEIAEoDjIXLnN0ZWFsdGguSW5zdHJ1bWVudFR5cGUSEAoIZXhj",
            "aGFuZ2UYBSABKAkSFAoMZGlzcGxheV9uYW1lGAYgASgJIlcKElN5bWJvbFNl",
            "YXJjaFVwZGF0ZRITCgtzZWFyY2hfdGVybRgBIAEoCRIsCgdyZXN1bHRzGAIg",
            "AygLMhsuc3RlYWx0aC5TeW1ib2xTZWFyY2hSZXN1bHQitwMKDVRvcFN5bWJv",
            "bEl0ZW0SEQoJdGltZXN0YW1wGAEgASgEEg4KBnN5bWJvbBgCIAEoCRISCgp1",
            "bmRlcmx5aW5nGAMgASgJEhAKCGN1cnJlbmN5GAQgASgJEjAKD2luc3RydW1l",
            "bnRfdHlwZRgFIAEoDjIXLnN0ZWFsdGguSW5zdHJ1bWVudFR5cGUSEAoIZXhj",
            "aGFuZ2UYBiABKAkSFAoMZGlzcGxheV9uYW1lGAcgASgJEhYKDmVudHJ5X3By",
            "b2dyZXNzGAggASgREicKBnNpZ25hbBgJIAEoDjIXLnN0ZWFsdGguU3RyYXRl",
            "Z3lTaWduYWwSLwoRcGVyY2VwdGlvbl9zaWduYWwYCiABKA4yFC5zdGVhbHRo",
            "LkdhdWdlU2lnbmFsEi8KEWNvbW1pdG1lbnRfc2lnbmFsGAsgASgOMhQuc3Rl",
            "YWx0aC5HYXVnZVNpZ25hbBIuChBzZW50aW1lbnRfc2lnbmFsGAwgASgOMhQu",
            "c3RlYWx0aC5HYXVnZVNpZ25hbBIwChJlcXVpbGlicml1bV9zaWduYWwYDSAB",
            "KA4yFC5zdGVhbHRoLkdhdWdlU2lnbmFsIjsKEFRvcFN5bWJvbHNVcGRhdGUS",
            "JwoHc3ltYm9scxgBIAMoCzIWLnN0ZWFsdGguVG9wU3ltYm9sSXRlbSrKAQoO",
            "SW5zdHJ1bWVudFR5cGUSEAoMTm9JbnN0cnVtZW50EAASDwoLQ29tbW9uU3Rv",
            "Y2sQARIPCgtTdG9ja09wdGlvbhACEgoKBkZ1dHVyZRADEgkKBUluZGV4EAQS",
            "EQoNRm9yZXhDb250cmFjdBAFEhAKDEZ1dHVyZU9wdGlvbhAGEhQKEEZ1dHVy",
            "ZUluc3RydW1lbnQQBxIJCgVDb21ibxAIEhMKD0NvbWJvSW5zdHJ1bWVudBAJ",
            "EhIKDkNyeXB0b0N1cnJlbmN5EAoqLQoJUHV0T3JDYWxsEg0KCU5vUHV0Q2Fs",
            "bBAAEgcKA1B1dBABEggKBENhbGwQAio7Cg5TdHJhdGVneVNpZ25hbBIICgRO",
            "b25lEAASDgoKTG9uZ1NpZ25hbBABEg8KC1Nob3J0U2lnbmFsEAIqQwoLR2F1",
            "Z2VTaWduYWwSCwoHVW5rbm93bhAAEgkKBVNob3J0EAESCAoERmxhdBACEggK",
            "BExvbmcQAxIICgREdWFsEARCHqoCG1F1YW50R2F0ZS5BUEkuUHJvdG8uU3Rl",
            "YWx0aGIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::QuantGate.API.Proto.Stealth.InstrumentType), typeof(global::QuantGate.API.Proto.Stealth.PutOrCall), typeof(global::QuantGate.API.Proto.Stealth.StrategySignal), typeof(global::QuantGate.API.Proto.Stealth.GaugeSignal), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.SentimentSpline), global::QuantGate.API.Proto.Stealth.SentimentSpline.Parser, new[]{ "Average", "I", "J", "X", "Y", "Z" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.SentimentUpdate), global::QuantGate.API.Proto.Stealth.SentimentUpdate.Parser, new[]{ "Timestamp", "Lengths", "Colors", "IsDirty" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.EquilibriumUpdate), global::QuantGate.API.Proto.Stealth.EquilibriumUpdate.Parser, new[]{ "Timestamp", "EquilibriumPrice", "GapSize", "High", "Low", "Projected", "Bias", "LastPrice", "IsDirty" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.MultiframeUpdate), global::QuantGate.API.Proto.Stealth.MultiframeUpdate.Parser, new[]{ "Timestamp", "Min5", "Min10", "Min15", "Min30", "Min45", "Min60", "Min120", "Min180", "Min240", "Day1", "IsDirty" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.TriggerUpdate), global::QuantGate.API.Proto.Stealth.TriggerUpdate.Parser, new[]{ "Timestamp", "Bias", "Perception", "Sentiment", "Commitment", "EquilibriumPrice", "GapSize", "LastPrice", "IsDirty" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.SingleValueUpdate), global::QuantGate.API.Proto.Stealth.SingleValueUpdate.Parser, new[]{ "Timestamp", "Value", "IsDirty" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.StrategyUpdate), global::QuantGate.API.Proto.Stealth.StrategyUpdate.Parser, new[]{ "Timestamp", "EntryProgress", "ExitProgress", "Signal", "PerceptionLevel", "PerceptionSignal", "CommitmentLevel", "CommitmentSignal", "SentimentSignal", "EquilibriumSignal", "SentimentLevel", "EquilibriumLevel" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.SinglePriceUpdate), global::QuantGate.API.Proto.Stealth.SinglePriceUpdate.Parser, new[]{ "Timestamp", "Value", "IsDirty" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.TickValue), global::QuantGate.API.Proto.Stealth.TickValue.Parser, new[]{ "Start", "Tick", "Denominator", "Decimals", "Format" }, null, new[]{ typeof(global::QuantGate.API.Proto.Stealth.TickValue.Types.TickFormat) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.TradingSession), global::QuantGate.API.Proto.Stealth.TradingSession.Parser, new[]{ "Close", "Length" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.InstrumentUpdate), global::QuantGate.API.Proto.Stealth.InstrumentUpdate.Parser, new[]{ "Symbol", "Underlying", "Currency", "Exchange", "InstrumentType", "PutOrCall", "Strike", "ExpiryDate", "Multiplier", "DisplayName", "TimeZone", "TickValues", "TradingSessions", "BrokerSymbols" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.SymbolSearchResult), global::QuantGate.API.Proto.Stealth.SymbolSearchResult.Parser, new[]{ "Symbol", "Underlying", "Currency", "InstrumentType", "Exchange", "DisplayName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.SymbolSearchUpdate), global::QuantGate.API.Proto.Stealth.SymbolSearchUpdate.Parser, new[]{ "SearchTerm", "Results" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.TopSymbolItem), global::QuantGate.API.Proto.Stealth.TopSymbolItem.Parser, new[]{ "Timestamp", "Symbol", "Underlying", "Currency", "InstrumentType", "Exchange", "DisplayName", "EntryProgress", "Signal", "PerceptionSignal", "CommitmentSignal", "SentimentSignal", "EquilibriumSignal" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::QuantGate.API.Proto.Stealth.TopSymbolsUpdate), global::QuantGate.API.Proto.Stealth.TopSymbolsUpdate.Parser, new[]{ "Symbols" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// The type of instrument being traded. 
  /// </summary>
  internal enum InstrumentType {
    /// <summary>
    /// Not a valid instrument.
    /// </summary>
    [pbr::OriginalName("NoInstrument")] NoInstrument = 0,
    /// <summary>
    /// Common stock.
    /// </summary>
    [pbr::OriginalName("CommonStock")] CommonStock = 1,
    /// <summary>
    /// Stock option.
    /// </summary>
    [pbr::OriginalName("StockOption")] StockOption = 2,
    /// <summary>
    /// Future.
    /// </summary>
    [pbr::OriginalName("Future")] Future = 3,
    /// <summary>
    /// Index.
    /// </summary>
    [pbr::OriginalName("Index")] Index = 4,
    /// <summary>
    /// Foreign Exchange (Currency).
    /// </summary>
    [pbr::OriginalName("ForexContract")] ForexContract = 5,
    /// <summary>
    /// Future option.
    /// </summary>
    [pbr::OriginalName("FutureOption")] FutureOption = 6,
    /// <summary>
    /// Future instrument (underlying).
    /// </summary>
    [pbr::OriginalName("FutureInstrument")] FutureInstrument = 7,
    /// <summary>
    /// Combo pairing.
    /// </summary>
    [pbr::OriginalName("Combo")] Combo = 8,
    /// <summary>
    /// Combo underlying.
    /// </summary>
    [pbr::OriginalName("ComboInstrument")] ComboInstrument = 9,
    /// <summary>
    /// Crypto Currency (Bitcoin, etc.)
    /// </summary>
    [pbr::OriginalName("CryptoCurrency")] CryptoCurrency = 10,
  }

  /// <summary>
  /// The Put/Call side ("right") of an option. 
  /// </summary>
  internal enum PutOrCall {
    /// <summary>
    /// Instrument is not an option.
    /// </summary>
    [pbr::OriginalName("NoPutCall")] NoPutCall = 0,
    /// <summary>
    /// Put Option (option to sell at strike).
    /// </summary>
    [pbr::OriginalName("Put")] Put = 1,
    /// <summary>
    /// Call Option (option to buy at strike).
    /// </summary>
    [pbr::OriginalName("Call")] Call = 2,
  }

  /// <summary>
  /// Entry/Exit signal state for strategies. 
  /// </summary>
  public enum StrategySignal {
    /// <summary>
    /// No current signal.
    /// </summary>
    [pbr::OriginalName("None")] None = 0,
    /// <summary>
    /// Signal to enter a long position.
    /// </summary>
    [pbr::OriginalName("LongSignal")] LongSignal = 1,
    /// <summary>
    /// Signal to enter a short position.
    /// </summary>
    [pbr::OriginalName("ShortSignal")] ShortSignal = 2,
  }

  /// <summary>
  /// Gauge signal state for strategies (PCES lights). 
  /// </summary>
  public enum GaugeSignal {
    /// <summary>
    /// Unknown signal (gauge signal not set - use default).
    /// </summary>
    [pbr::OriginalName("Unknown")] Unknown = 0,
    /// <summary>
    /// Signal to enter a short position.
    /// </summary>
    [pbr::OriginalName("Short")] Short = 1,
    /// <summary>
    /// No current signal.
    /// </summary>
    [pbr::OriginalName("Flat")] Flat = 2,
    /// <summary>
    /// Signal to enter a long position.
    /// </summary>
    [pbr::OriginalName("Long")] Long = 3,
    /// <summary>
    /// Dual signal (long or short - no specific direction).
    /// </summary>
    [pbr::OriginalName("Dual")] Dual = 4,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Holds the spline information for a sentiment length or color spline.
  /// Values should be converted to between -1 and 1 by dividing by 1000. 
  /// </summary>
  internal sealed partial class SentimentSpline : pb::IMessage<SentimentSpline> {
    private static readonly pb::MessageParser<SentimentSpline> _parser = new pb::MessageParser<SentimentSpline>(() => new SentimentSpline());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SentimentSpline> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SentimentSpline() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SentimentSpline(SentimentSpline other) : this() {
      average_ = other.average_;
      i_ = other.i_;
      j_ = other.j_;
      x_ = other.x_;
      y_ = other.y_;
      z_ = other.z_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SentimentSpline Clone() {
      return new SentimentSpline(this);
    }

    /// <summary>Field number for the "average" field.</summary>
    public const int AverageFieldNumber = 1;
    private int average_;
    /// <summary>
    /// Average length. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Average {
      get { return average_; }
      set {
        average_ = value;
      }
    }

    /// <summary>Field number for the "i" field.</summary>
    public const int IFieldNumber = 2;
    private uint i_;
    /// <summary>
    /// First spline point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint I {
      get { return i_; }
      set {
        i_ = value;
      }
    }

    /// <summary>Field number for the "j" field.</summary>
    public const int JFieldNumber = 3;
    private uint j_;
    /// <summary>
    /// Second spline point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint J {
      get { return j_; }
      set {
        j_ = value;
      }
    }

    /// <summary>Field number for the "x" field.</summary>
    public const int XFieldNumber = 4;
    private int x_;
    /// <summary>
    /// Position at point 0. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int X {
      get { return x_; }
      set {
        x_ = value;
      }
    }

    /// <summary>Field number for the "y" field.</summary>
    public const int YFieldNumber = 5;
    private int y_;
    /// <summary>
    /// Position at point i. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Y {
      get { return y_; }
      set {
        y_ = value;
      }
    }

    /// <summary>Field number for the "z" field.</summary>
    public const int ZFieldNumber = 6;
    private int z_;
    /// <summary>
    /// Position at point j. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Z {
      get { return z_; }
      set {
        z_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SentimentSpline);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SentimentSpline other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Average != other.Average) return false;
      if (I != other.I) return false;
      if (J != other.J) return false;
      if (X != other.X) return false;
      if (Y != other.Y) return false;
      if (Z != other.Z) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Average != 0) hash ^= Average.GetHashCode();
      if (I != 0) hash ^= I.GetHashCode();
      if (J != 0) hash ^= J.GetHashCode();
      if (X != 0) hash ^= X.GetHashCode();
      if (Y != 0) hash ^= Y.GetHashCode();
      if (Z != 0) hash ^= Z.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Average != 0) {
        output.WriteRawTag(8);
        output.WriteSInt32(Average);
      }
      if (I != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(I);
      }
      if (J != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(J);
      }
      if (X != 0) {
        output.WriteRawTag(32);
        output.WriteSInt32(X);
      }
      if (Y != 0) {
        output.WriteRawTag(40);
        output.WriteSInt32(Y);
      }
      if (Z != 0) {
        output.WriteRawTag(48);
        output.WriteSInt32(Z);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Average != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Average);
      }
      if (I != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(I);
      }
      if (J != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(J);
      }
      if (X != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(X);
      }
      if (Y != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Y);
      }
      if (Z != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Z);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SentimentSpline other) {
      if (other == null) {
        return;
      }
      if (other.Average != 0) {
        Average = other.Average;
      }
      if (other.I != 0) {
        I = other.I;
      }
      if (other.J != 0) {
        J = other.J;
      }
      if (other.X != 0) {
        X = other.X;
      }
      if (other.Y != 0) {
        Y = other.Y;
      }
      if (other.Z != 0) {
        Z = other.Z;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Average = input.ReadSInt32();
            break;
          }
          case 16: {
            I = input.ReadUInt32();
            break;
          }
          case 24: {
            J = input.ReadUInt32();
            break;
          }
          case 32: {
            X = input.ReadSInt32();
            break;
          }
          case 40: {
            Y = input.ReadSInt32();
            break;
          }
          case 48: {
            Z = input.ReadSInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// SentimentUpdate represents a new sentiment subscription update. 
  /// </summary>
  internal sealed partial class SentimentUpdate : pb::IMessage<SentimentUpdate> {
    private static readonly pb::MessageParser<SentimentUpdate> _parser = new pb::MessageParser<SentimentUpdate>(() => new SentimentUpdate());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SentimentUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SentimentUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SentimentUpdate(SentimentUpdate other) : this() {
      timestamp_ = other.timestamp_;
      Lengths = other.lengths_ != null ? other.Lengths.Clone() : null;
      Colors = other.colors_ != null ? other.Colors.Clone() : null;
      isDirty_ = other.isDirty_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SentimentUpdate Clone() {
      return new SentimentUpdate(this);
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 1;
    private ulong timestamp_;
    /// <summary>
    /// The timestamp of the latest update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "lengths" field.</summary>
    public const int LengthsFieldNumber = 2;
    private global::QuantGate.API.Proto.Stealth.SentimentSpline lengths_;
    /// <summary>
    /// Bar color spline component of sentiment gauge.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.SentimentSpline Lengths {
      get { return lengths_; }
      set {
        lengths_ = value;
      }
    }

    /// <summary>Field number for the "colors" field.</summary>
    public const int ColorsFieldNumber = 3;
    private global::QuantGate.API.Proto.Stealth.SentimentSpline colors_;
    /// <summary>
    /// Bar length component of sentiment gauge.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.SentimentSpline Colors {
      get { return colors_; }
      set {
        colors_ = value;
      }
    }

    /// <summary>Field number for the "is_dirty" field.</summary>
    public const int IsDirtyFieldNumber = 4;
    private bool isDirty_;
    /// <summary>
    /// Is the data that generated this potentially dirty (or stale)?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDirty {
      get { return isDirty_; }
      set {
        isDirty_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SentimentUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SentimentUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Timestamp != other.Timestamp) return false;
      if (!object.Equals(Lengths, other.Lengths)) return false;
      if (!object.Equals(Colors, other.Colors)) return false;
      if (IsDirty != other.IsDirty) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Timestamp != 0UL) hash ^= Timestamp.GetHashCode();
      if (lengths_ != null) hash ^= Lengths.GetHashCode();
      if (colors_ != null) hash ^= Colors.GetHashCode();
      if (IsDirty != false) hash ^= IsDirty.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Timestamp != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Timestamp);
      }
      if (lengths_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Lengths);
      }
      if (colors_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Colors);
      }
      if (IsDirty != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsDirty);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Timestamp != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (lengths_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lengths);
      }
      if (colors_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Colors);
      }
      if (IsDirty != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SentimentUpdate other) {
      if (other == null) {
        return;
      }
      if (other.Timestamp != 0UL) {
        Timestamp = other.Timestamp;
      }
      if (other.lengths_ != null) {
        if (lengths_ == null) {
          lengths_ = new global::QuantGate.API.Proto.Stealth.SentimentSpline();
        }
        Lengths.MergeFrom(other.Lengths);
      }
      if (other.colors_ != null) {
        if (colors_ == null) {
          colors_ = new global::QuantGate.API.Proto.Stealth.SentimentSpline();
        }
        Colors.MergeFrom(other.Colors);
      }
      if (other.IsDirty != false) {
        IsDirty = other.IsDirty;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 18: {
            if (lengths_ == null) {
              lengths_ = new global::QuantGate.API.Proto.Stealth.SentimentSpline();
            }
            input.ReadMessage(lengths_);
            break;
          }
          case 26: {
            if (colors_ == null) {
              colors_ = new global::QuantGate.API.Proto.Stealth.SentimentSpline();
            }
            input.ReadMessage(colors_);
            break;
          }
          case 32: {
            IsDirty = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// EquilibriumUpdate represents a new equilibrium subscription update.
  /// All prices (and gap size) are converted to long values.
  /// Values should be converted to between -1 and 1 by dividing by 1000. 
  /// </summary>
  internal sealed partial class EquilibriumUpdate : pb::IMessage<EquilibriumUpdate> {
    private static readonly pb::MessageParser<EquilibriumUpdate> _parser = new pb::MessageParser<EquilibriumUpdate>(() => new EquilibriumUpdate());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EquilibriumUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EquilibriumUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EquilibriumUpdate(EquilibriumUpdate other) : this() {
      timestamp_ = other.timestamp_;
      equilibriumPrice_ = other.equilibriumPrice_;
      gapSize_ = other.gapSize_;
      high_ = other.high_;
      low_ = other.low_;
      projected_ = other.projected_;
      bias_ = other.bias_;
      lastPrice_ = other.lastPrice_;
      isDirty_ = other.isDirty_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EquilibriumUpdate Clone() {
      return new EquilibriumUpdate(this);
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 1;
    private ulong timestamp_;
    /// <summary>
    /// The timestamp of the latest update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "equilibrium_price" field.</summary>
    public const int EquilibriumPriceFieldNumber = 2;
    private ulong equilibriumPrice_;
    /// <summary>
    /// The equilibrium price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong EquilibriumPrice {
      get { return equilibriumPrice_; }
      set {
        equilibriumPrice_ = value;
      }
    }

    /// <summary>Field number for the "gap_size" field.</summary>
    public const int GapSizeFieldNumber = 3;
    private ulong gapSize_;
    /// <summary>
    /// The gap size of each equilibrium deviation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong GapSize {
      get { return gapSize_; }
      set {
        gapSize_ = value;
      }
    }

    /// <summary>Field number for the "high" field.</summary>
    public const int HighFieldNumber = 4;
    private int high_;
    /// <summary>
    /// The position of the high value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int High {
      get { return high_; }
      set {
        high_ = value;
      }
    }

    /// <summary>Field number for the "low" field.</summary>
    public const int LowFieldNumber = 5;
    private int low_;
    /// <summary>
    /// The position of the low value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Low {
      get { return low_; }
      set {
        low_ = value;
      }
    }

    /// <summary>Field number for the "projected" field.</summary>
    public const int ProjectedFieldNumber = 6;
    private int projected_;
    /// <summary>
    /// Position of the projected value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Projected {
      get { return projected_; }
      set {
        projected_ = value;
      }
    }

    /// <summary>Field number for the "bias" field.</summary>
    public const int BiasFieldNumber = 7;
    private int bias_;
    /// <summary>
    /// The bias (determined by the slope, -1000 to 1000).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Bias {
      get { return bias_; }
      set {
        bias_ = value;
      }
    }

    /// <summary>Field number for the "last_price" field.</summary>
    public const int LastPriceFieldNumber = 8;
    private ulong lastPrice_;
    /// <summary>
    /// Last traded price at time of calculation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong LastPrice {
      get { return lastPrice_; }
      set {
        lastPrice_ = value;
      }
    }

    /// <summary>Field number for the "is_dirty" field.</summary>
    public const int IsDirtyFieldNumber = 9;
    private bool isDirty_;
    /// <summary>
    /// Is the data that generated this potentially dirty (or stale)?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDirty {
      get { return isDirty_; }
      set {
        isDirty_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EquilibriumUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EquilibriumUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Timestamp != other.Timestamp) return false;
      if (EquilibriumPrice != other.EquilibriumPrice) return false;
      if (GapSize != other.GapSize) return false;
      if (High != other.High) return false;
      if (Low != other.Low) return false;
      if (Projected != other.Projected) return false;
      if (Bias != other.Bias) return false;
      if (LastPrice != other.LastPrice) return false;
      if (IsDirty != other.IsDirty) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Timestamp != 0UL) hash ^= Timestamp.GetHashCode();
      if (EquilibriumPrice != 0UL) hash ^= EquilibriumPrice.GetHashCode();
      if (GapSize != 0UL) hash ^= GapSize.GetHashCode();
      if (High != 0) hash ^= High.GetHashCode();
      if (Low != 0) hash ^= Low.GetHashCode();
      if (Projected != 0) hash ^= Projected.GetHashCode();
      if (Bias != 0) hash ^= Bias.GetHashCode();
      if (LastPrice != 0UL) hash ^= LastPrice.GetHashCode();
      if (IsDirty != false) hash ^= IsDirty.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Timestamp != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Timestamp);
      }
      if (EquilibriumPrice != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(EquilibriumPrice);
      }
      if (GapSize != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(GapSize);
      }
      if (High != 0) {
        output.WriteRawTag(32);
        output.WriteSInt32(High);
      }
      if (Low != 0) {
        output.WriteRawTag(40);
        output.WriteSInt32(Low);
      }
      if (Projected != 0) {
        output.WriteRawTag(48);
        output.WriteSInt32(Projected);
      }
      if (Bias != 0) {
        output.WriteRawTag(56);
        output.WriteSInt32(Bias);
      }
      if (LastPrice != 0UL) {
        output.WriteRawTag(64);
        output.WriteUInt64(LastPrice);
      }
      if (IsDirty != false) {
        output.WriteRawTag(72);
        output.WriteBool(IsDirty);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Timestamp != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (EquilibriumPrice != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(EquilibriumPrice);
      }
      if (GapSize != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(GapSize);
      }
      if (High != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(High);
      }
      if (Low != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Low);
      }
      if (Projected != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Projected);
      }
      if (Bias != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Bias);
      }
      if (LastPrice != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(LastPrice);
      }
      if (IsDirty != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EquilibriumUpdate other) {
      if (other == null) {
        return;
      }
      if (other.Timestamp != 0UL) {
        Timestamp = other.Timestamp;
      }
      if (other.EquilibriumPrice != 0UL) {
        EquilibriumPrice = other.EquilibriumPrice;
      }
      if (other.GapSize != 0UL) {
        GapSize = other.GapSize;
      }
      if (other.High != 0) {
        High = other.High;
      }
      if (other.Low != 0) {
        Low = other.Low;
      }
      if (other.Projected != 0) {
        Projected = other.Projected;
      }
      if (other.Bias != 0) {
        Bias = other.Bias;
      }
      if (other.LastPrice != 0UL) {
        LastPrice = other.LastPrice;
      }
      if (other.IsDirty != false) {
        IsDirty = other.IsDirty;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 16: {
            EquilibriumPrice = input.ReadUInt64();
            break;
          }
          case 24: {
            GapSize = input.ReadUInt64();
            break;
          }
          case 32: {
            High = input.ReadSInt32();
            break;
          }
          case 40: {
            Low = input.ReadSInt32();
            break;
          }
          case 48: {
            Projected = input.ReadSInt32();
            break;
          }
          case 56: {
            Bias = input.ReadSInt32();
            break;
          }
          case 64: {
            LastPrice = input.ReadUInt64();
            break;
          }
          case 72: {
            IsDirty = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// MultiframeUpdate represents a new multi-timeframe equilibrium subscription update. 
  /// Values should be converted to between -1 and 1 by dividing by 1000. 
  /// </summary>
  internal sealed partial class MultiframeUpdate : pb::IMessage<MultiframeUpdate> {
    private static readonly pb::MessageParser<MultiframeUpdate> _parser = new pb::MessageParser<MultiframeUpdate>(() => new MultiframeUpdate());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MultiframeUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MultiframeUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MultiframeUpdate(MultiframeUpdate other) : this() {
      timestamp_ = other.timestamp_;
      min5_ = other.min5_;
      min10_ = other.min10_;
      min15_ = other.min15_;
      min30_ = other.min30_;
      min45_ = other.min45_;
      min60_ = other.min60_;
      min120_ = other.min120_;
      min180_ = other.min180_;
      min240_ = other.min240_;
      day1_ = other.day1_;
      isDirty_ = other.isDirty_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MultiframeUpdate Clone() {
      return new MultiframeUpdate(this);
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 1;
    private ulong timestamp_;
    /// <summary>
    /// The timestamp of the latest update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "min_5" field.</summary>
    public const int Min5FieldNumber = 2;
    private int min5_;
    /// <summary>
    /// The 5 minute value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Min5 {
      get { return min5_; }
      set {
        min5_ = value;
      }
    }

    /// <summary>Field number for the "min_10" field.</summary>
    public const int Min10FieldNumber = 3;
    private int min10_;
    /// <summary>
    /// The 10 minute value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Min10 {
      get { return min10_; }
      set {
        min10_ = value;
      }
    }

    /// <summary>Field number for the "min_15" field.</summary>
    public const int Min15FieldNumber = 4;
    private int min15_;
    /// <summary>
    /// The 15 minute value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Min15 {
      get { return min15_; }
      set {
        min15_ = value;
      }
    }

    /// <summary>Field number for the "min_30" field.</summary>
    public const int Min30FieldNumber = 5;
    private int min30_;
    /// <summary>
    /// The 30 minute value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Min30 {
      get { return min30_; }
      set {
        min30_ = value;
      }
    }

    /// <summary>Field number for the "min_45" field.</summary>
    public const int Min45FieldNumber = 6;
    private int min45_;
    /// <summary>
    /// The 45 minute value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Min45 {
      get { return min45_; }
      set {
        min45_ = value;
      }
    }

    /// <summary>Field number for the "min_60" field.</summary>
    public const int Min60FieldNumber = 7;
    private int min60_;
    /// <summary>
    /// The 60 minute value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Min60 {
      get { return min60_; }
      set {
        min60_ = value;
      }
    }

    /// <summary>Field number for the "min_120" field.</summary>
    public const int Min120FieldNumber = 8;
    private int min120_;
    /// <summary>
    /// The 120 minute value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Min120 {
      get { return min120_; }
      set {
        min120_ = value;
      }
    }

    /// <summary>Field number for the "min_180" field.</summary>
    public const int Min180FieldNumber = 9;
    private int min180_;
    /// <summary>
    /// The 180 minute value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Min180 {
      get { return min180_; }
      set {
        min180_ = value;
      }
    }

    /// <summary>Field number for the "min_240" field.</summary>
    public const int Min240FieldNumber = 10;
    private int min240_;
    /// <summary>
    /// The 240 minute value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Min240 {
      get { return min240_; }
      set {
        min240_ = value;
      }
    }

    /// <summary>Field number for the "day_1" field.</summary>
    public const int Day1FieldNumber = 11;
    private int day1_;
    /// <summary>
    /// The 1 day value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Day1 {
      get { return day1_; }
      set {
        day1_ = value;
      }
    }

    /// <summary>Field number for the "is_dirty" field.</summary>
    public const int IsDirtyFieldNumber = 12;
    private bool isDirty_;
    /// <summary>
    /// Is the data that generated this potentially dirty (or stale)?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDirty {
      get { return isDirty_; }
      set {
        isDirty_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MultiframeUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MultiframeUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Timestamp != other.Timestamp) return false;
      if (Min5 != other.Min5) return false;
      if (Min10 != other.Min10) return false;
      if (Min15 != other.Min15) return false;
      if (Min30 != other.Min30) return false;
      if (Min45 != other.Min45) return false;
      if (Min60 != other.Min60) return false;
      if (Min120 != other.Min120) return false;
      if (Min180 != other.Min180) return false;
      if (Min240 != other.Min240) return false;
      if (Day1 != other.Day1) return false;
      if (IsDirty != other.IsDirty) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Timestamp != 0UL) hash ^= Timestamp.GetHashCode();
      if (Min5 != 0) hash ^= Min5.GetHashCode();
      if (Min10 != 0) hash ^= Min10.GetHashCode();
      if (Min15 != 0) hash ^= Min15.GetHashCode();
      if (Min30 != 0) hash ^= Min30.GetHashCode();
      if (Min45 != 0) hash ^= Min45.GetHashCode();
      if (Min60 != 0) hash ^= Min60.GetHashCode();
      if (Min120 != 0) hash ^= Min120.GetHashCode();
      if (Min180 != 0) hash ^= Min180.GetHashCode();
      if (Min240 != 0) hash ^= Min240.GetHashCode();
      if (Day1 != 0) hash ^= Day1.GetHashCode();
      if (IsDirty != false) hash ^= IsDirty.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Timestamp != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Timestamp);
      }
      if (Min5 != 0) {
        output.WriteRawTag(16);
        output.WriteSInt32(Min5);
      }
      if (Min10 != 0) {
        output.WriteRawTag(24);
        output.WriteSInt32(Min10);
      }
      if (Min15 != 0) {
        output.WriteRawTag(32);
        output.WriteSInt32(Min15);
      }
      if (Min30 != 0) {
        output.WriteRawTag(40);
        output.WriteSInt32(Min30);
      }
      if (Min45 != 0) {
        output.WriteRawTag(48);
        output.WriteSInt32(Min45);
      }
      if (Min60 != 0) {
        output.WriteRawTag(56);
        output.WriteSInt32(Min60);
      }
      if (Min120 != 0) {
        output.WriteRawTag(64);
        output.WriteSInt32(Min120);
      }
      if (Min180 != 0) {
        output.WriteRawTag(72);
        output.WriteSInt32(Min180);
      }
      if (Min240 != 0) {
        output.WriteRawTag(80);
        output.WriteSInt32(Min240);
      }
      if (Day1 != 0) {
        output.WriteRawTag(88);
        output.WriteSInt32(Day1);
      }
      if (IsDirty != false) {
        output.WriteRawTag(96);
        output.WriteBool(IsDirty);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Timestamp != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (Min5 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Min5);
      }
      if (Min10 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Min10);
      }
      if (Min15 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Min15);
      }
      if (Min30 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Min30);
      }
      if (Min45 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Min45);
      }
      if (Min60 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Min60);
      }
      if (Min120 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Min120);
      }
      if (Min180 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Min180);
      }
      if (Min240 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Min240);
      }
      if (Day1 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Day1);
      }
      if (IsDirty != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MultiframeUpdate other) {
      if (other == null) {
        return;
      }
      if (other.Timestamp != 0UL) {
        Timestamp = other.Timestamp;
      }
      if (other.Min5 != 0) {
        Min5 = other.Min5;
      }
      if (other.Min10 != 0) {
        Min10 = other.Min10;
      }
      if (other.Min15 != 0) {
        Min15 = other.Min15;
      }
      if (other.Min30 != 0) {
        Min30 = other.Min30;
      }
      if (other.Min45 != 0) {
        Min45 = other.Min45;
      }
      if (other.Min60 != 0) {
        Min60 = other.Min60;
      }
      if (other.Min120 != 0) {
        Min120 = other.Min120;
      }
      if (other.Min180 != 0) {
        Min180 = other.Min180;
      }
      if (other.Min240 != 0) {
        Min240 = other.Min240;
      }
      if (other.Day1 != 0) {
        Day1 = other.Day1;
      }
      if (other.IsDirty != false) {
        IsDirty = other.IsDirty;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 16: {
            Min5 = input.ReadSInt32();
            break;
          }
          case 24: {
            Min10 = input.ReadSInt32();
            break;
          }
          case 32: {
            Min15 = input.ReadSInt32();
            break;
          }
          case 40: {
            Min30 = input.ReadSInt32();
            break;
          }
          case 48: {
            Min45 = input.ReadSInt32();
            break;
          }
          case 56: {
            Min60 = input.ReadSInt32();
            break;
          }
          case 64: {
            Min120 = input.ReadSInt32();
            break;
          }
          case 72: {
            Min180 = input.ReadSInt32();
            break;
          }
          case 80: {
            Min240 = input.ReadSInt32();
            break;
          }
          case 88: {
            Day1 = input.ReadSInt32();
            break;
          }
          case 96: {
            IsDirty = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// TriggerUpdate represents a new trigger subscription update. 
  /// All prices (and gap size) are converted to long values.
  /// Values should be converted to between -1 and 1 by subtracting 1001 and dividing by 1000. 
  /// </summary>
  internal sealed partial class TriggerUpdate : pb::IMessage<TriggerUpdate> {
    private static readonly pb::MessageParser<TriggerUpdate> _parser = new pb::MessageParser<TriggerUpdate>(() => new TriggerUpdate());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TriggerUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TriggerUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TriggerUpdate(TriggerUpdate other) : this() {
      timestamp_ = other.timestamp_;
      bias_ = other.bias_;
      perception_ = other.perception_;
      sentiment_ = other.sentiment_;
      commitment_ = other.commitment_;
      equilibriumPrice_ = other.equilibriumPrice_;
      gapSize_ = other.gapSize_;
      lastPrice_ = other.lastPrice_;
      isDirty_ = other.isDirty_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TriggerUpdate Clone() {
      return new TriggerUpdate(this);
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 1;
    private ulong timestamp_;
    /// <summary>
    /// The timestamp of the latest update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "bias" field.</summary>
    public const int BiasFieldNumber = 2;
    private int bias_;
    /// <summary>
    /// The bias value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Bias {
      get { return bias_; }
      set {
        bias_ = value;
      }
    }

    /// <summary>Field number for the "perception" field.</summary>
    public const int PerceptionFieldNumber = 3;
    private int perception_;
    /// <summary>
    /// The perception value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Perception {
      get { return perception_; }
      set {
        perception_ = value;
      }
    }

    /// <summary>Field number for the "sentiment" field.</summary>
    public const int SentimentFieldNumber = 4;
    private int sentiment_;
    /// <summary>
    /// Sentiment length value at point 0. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Sentiment {
      get { return sentiment_; }
      set {
        sentiment_ = value;
      }
    }

    /// <summary>Field number for the "commitment" field.</summary>
    public const int CommitmentFieldNumber = 5;
    private int commitment_;
    /// <summary>
    /// The commitment value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Commitment {
      get { return commitment_; }
      set {
        commitment_ = value;
      }
    }

    /// <summary>Field number for the "equilibrium_price" field.</summary>
    public const int EquilibriumPriceFieldNumber = 6;
    private ulong equilibriumPrice_;
    /// <summary>
    /// The equilibrium price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong EquilibriumPrice {
      get { return equilibriumPrice_; }
      set {
        equilibriumPrice_ = value;
      }
    }

    /// <summary>Field number for the "gap_size" field.</summary>
    public const int GapSizeFieldNumber = 7;
    private ulong gapSize_;
    /// <summary>
    /// The gap size of each equilibrium deviation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong GapSize {
      get { return gapSize_; }
      set {
        gapSize_ = value;
      }
    }

    /// <summary>Field number for the "last_price" field.</summary>
    public const int LastPriceFieldNumber = 8;
    private ulong lastPrice_;
    /// <summary>
    /// Last traded price at time of calculation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong LastPrice {
      get { return lastPrice_; }
      set {
        lastPrice_ = value;
      }
    }

    /// <summary>Field number for the "is_dirty" field.</summary>
    public const int IsDirtyFieldNumber = 9;
    private bool isDirty_;
    /// <summary>
    /// Is the data that generated this potentially dirty (or stale)?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDirty {
      get { return isDirty_; }
      set {
        isDirty_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TriggerUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TriggerUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Timestamp != other.Timestamp) return false;
      if (Bias != other.Bias) return false;
      if (Perception != other.Perception) return false;
      if (Sentiment != other.Sentiment) return false;
      if (Commitment != other.Commitment) return false;
      if (EquilibriumPrice != other.EquilibriumPrice) return false;
      if (GapSize != other.GapSize) return false;
      if (LastPrice != other.LastPrice) return false;
      if (IsDirty != other.IsDirty) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Timestamp != 0UL) hash ^= Timestamp.GetHashCode();
      if (Bias != 0) hash ^= Bias.GetHashCode();
      if (Perception != 0) hash ^= Perception.GetHashCode();
      if (Sentiment != 0) hash ^= Sentiment.GetHashCode();
      if (Commitment != 0) hash ^= Commitment.GetHashCode();
      if (EquilibriumPrice != 0UL) hash ^= EquilibriumPrice.GetHashCode();
      if (GapSize != 0UL) hash ^= GapSize.GetHashCode();
      if (LastPrice != 0UL) hash ^= LastPrice.GetHashCode();
      if (IsDirty != false) hash ^= IsDirty.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Timestamp != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Timestamp);
      }
      if (Bias != 0) {
        output.WriteRawTag(16);
        output.WriteSInt32(Bias);
      }
      if (Perception != 0) {
        output.WriteRawTag(24);
        output.WriteSInt32(Perception);
      }
      if (Sentiment != 0) {
        output.WriteRawTag(32);
        output.WriteSInt32(Sentiment);
      }
      if (Commitment != 0) {
        output.WriteRawTag(40);
        output.WriteSInt32(Commitment);
      }
      if (EquilibriumPrice != 0UL) {
        output.WriteRawTag(48);
        output.WriteUInt64(EquilibriumPrice);
      }
      if (GapSize != 0UL) {
        output.WriteRawTag(56);
        output.WriteUInt64(GapSize);
      }
      if (LastPrice != 0UL) {
        output.WriteRawTag(64);
        output.WriteUInt64(LastPrice);
      }
      if (IsDirty != false) {
        output.WriteRawTag(72);
        output.WriteBool(IsDirty);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Timestamp != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (Bias != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Bias);
      }
      if (Perception != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Perception);
      }
      if (Sentiment != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Sentiment);
      }
      if (Commitment != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Commitment);
      }
      if (EquilibriumPrice != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(EquilibriumPrice);
      }
      if (GapSize != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(GapSize);
      }
      if (LastPrice != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(LastPrice);
      }
      if (IsDirty != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TriggerUpdate other) {
      if (other == null) {
        return;
      }
      if (other.Timestamp != 0UL) {
        Timestamp = other.Timestamp;
      }
      if (other.Bias != 0) {
        Bias = other.Bias;
      }
      if (other.Perception != 0) {
        Perception = other.Perception;
      }
      if (other.Sentiment != 0) {
        Sentiment = other.Sentiment;
      }
      if (other.Commitment != 0) {
        Commitment = other.Commitment;
      }
      if (other.EquilibriumPrice != 0UL) {
        EquilibriumPrice = other.EquilibriumPrice;
      }
      if (other.GapSize != 0UL) {
        GapSize = other.GapSize;
      }
      if (other.LastPrice != 0UL) {
        LastPrice = other.LastPrice;
      }
      if (other.IsDirty != false) {
        IsDirty = other.IsDirty;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 16: {
            Bias = input.ReadSInt32();
            break;
          }
          case 24: {
            Perception = input.ReadSInt32();
            break;
          }
          case 32: {
            Sentiment = input.ReadSInt32();
            break;
          }
          case 40: {
            Commitment = input.ReadSInt32();
            break;
          }
          case 48: {
            EquilibriumPrice = input.ReadUInt64();
            break;
          }
          case 56: {
            GapSize = input.ReadUInt64();
            break;
          }
          case 64: {
            LastPrice = input.ReadUInt64();
            break;
          }
          case 72: {
            IsDirty = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// SingleValueUpdate represents a new subscription update for a gauge that returns a single
  /// value (such as Perception, Commitment, Headroom, Book Pressure, or SMA).
  /// Values should be converted to between -1 and 1 by dividing by 1000. 
  /// </summary>
  internal sealed partial class SingleValueUpdate : pb::IMessage<SingleValueUpdate> {
    private static readonly pb::MessageParser<SingleValueUpdate> _parser = new pb::MessageParser<SingleValueUpdate>(() => new SingleValueUpdate());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SingleValueUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SingleValueUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SingleValueUpdate(SingleValueUpdate other) : this() {
      timestamp_ = other.timestamp_;
      value_ = other.value_;
      isDirty_ = other.isDirty_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SingleValueUpdate Clone() {
      return new SingleValueUpdate(this);
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 1;
    private ulong timestamp_;
    /// <summary>
    /// The timestamp of the latest update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private int value_;
    /// <summary>
    /// The single value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Value {
      get { return value_; }
      set {
        value_ = value;
      }
    }

    /// <summary>Field number for the "is_dirty" field.</summary>
    public const int IsDirtyFieldNumber = 3;
    private bool isDirty_;
    /// <summary>
    /// Is the data that generated this potentially dirty (or stale)?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDirty {
      get { return isDirty_; }
      set {
        isDirty_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SingleValueUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SingleValueUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Timestamp != other.Timestamp) return false;
      if (Value != other.Value) return false;
      if (IsDirty != other.IsDirty) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Timestamp != 0UL) hash ^= Timestamp.GetHashCode();
      if (Value != 0) hash ^= Value.GetHashCode();
      if (IsDirty != false) hash ^= IsDirty.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Timestamp != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Timestamp);
      }
      if (Value != 0) {
        output.WriteRawTag(16);
        output.WriteSInt32(Value);
      }
      if (IsDirty != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsDirty);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Timestamp != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (Value != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Value);
      }
      if (IsDirty != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SingleValueUpdate other) {
      if (other == null) {
        return;
      }
      if (other.Timestamp != 0UL) {
        Timestamp = other.Timestamp;
      }
      if (other.Value != 0) {
        Value = other.Value;
      }
      if (other.IsDirty != false) {
        IsDirty = other.IsDirty;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 16: {
            Value = input.ReadSInt32();
            break;
          }
          case 24: {
            IsDirty = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// StrategyUpdate represents a new subscription update for a subscribed strategy. 
  /// </summary>
  internal sealed partial class StrategyUpdate : pb::IMessage<StrategyUpdate> {
    private static readonly pb::MessageParser<StrategyUpdate> _parser = new pb::MessageParser<StrategyUpdate>(() => new StrategyUpdate());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StrategyUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StrategyUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StrategyUpdate(StrategyUpdate other) : this() {
      timestamp_ = other.timestamp_;
      entryProgress_ = other.entryProgress_;
      exitProgress_ = other.exitProgress_;
      signal_ = other.signal_;
      perceptionLevel_ = other.perceptionLevel_;
      perceptionSignal_ = other.perceptionSignal_;
      commitmentLevel_ = other.commitmentLevel_;
      commitmentSignal_ = other.commitmentSignal_;
      sentimentSignal_ = other.sentimentSignal_;
      equilibriumSignal_ = other.equilibriumSignal_;
      sentimentLevel_ = other.sentimentLevel_;
      equilibriumLevel_ = other.equilibriumLevel_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StrategyUpdate Clone() {
      return new StrategyUpdate(this);
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 1;
    private ulong timestamp_;
    /// <summary>
    /// The timestamp of the latest update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "entry_progress" field.</summary>
    public const int EntryProgressFieldNumber = 2;
    private int entryProgress_;
    /// <summary>
    /// The entry progress value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int EntryProgress {
      get { return entryProgress_; }
      set {
        entryProgress_ = value;
      }
    }

    /// <summary>Field number for the "exit_progress" field.</summary>
    public const int ExitProgressFieldNumber = 3;
    private int exitProgress_;
    /// <summary>
    /// The exit progress value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ExitProgress {
      get { return exitProgress_; }
      set {
        exitProgress_ = value;
      }
    }

    /// <summary>Field number for the "signal" field.</summary>
    public const int SignalFieldNumber = 4;
    private global::QuantGate.API.Proto.Stealth.StrategySignal signal_ = 0;
    /// <summary>
    /// The entry signal for the strategy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.StrategySignal Signal {
      get { return signal_; }
      set {
        signal_ = value;
      }
    }

    /// <summary>Field number for the "perception_level" field.</summary>
    public const int PerceptionLevelFieldNumber = 5;
    private uint perceptionLevel_;
    /// <summary>
    /// The perception level ( 0=unset, else value=(x-1001)/1000 )
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint PerceptionLevel {
      get { return perceptionLevel_; }
      set {
        perceptionLevel_ = value;
      }
    }

    /// <summary>Field number for the "perception_signal" field.</summary>
    public const int PerceptionSignalFieldNumber = 6;
    private global::QuantGate.API.Proto.Stealth.GaugeSignal perceptionSignal_ = 0;
    /// <summary>
    /// The signal tied to the perception level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.GaugeSignal PerceptionSignal {
      get { return perceptionSignal_; }
      set {
        perceptionSignal_ = value;
      }
    }

    /// <summary>Field number for the "commitment_level" field.</summary>
    public const int CommitmentLevelFieldNumber = 7;
    private uint commitmentLevel_;
    /// <summary>
    /// The commitment level ( 0=unset, else value=(x-1001)/1000 )
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint CommitmentLevel {
      get { return commitmentLevel_; }
      set {
        commitmentLevel_ = value;
      }
    }

    /// <summary>Field number for the "commitment_signal" field.</summary>
    public const int CommitmentSignalFieldNumber = 8;
    private global::QuantGate.API.Proto.Stealth.GaugeSignal commitmentSignal_ = 0;
    /// <summary>
    /// The signal tied to the commitment level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.GaugeSignal CommitmentSignal {
      get { return commitmentSignal_; }
      set {
        commitmentSignal_ = value;
      }
    }

    /// <summary>Field number for the "sentiment_signal" field.</summary>
    public const int SentimentSignalFieldNumber = 9;
    private global::QuantGate.API.Proto.Stealth.GaugeSignal sentimentSignal_ = 0;
    /// <summary>
    /// The signal tied to the 50t sentiment indication.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.GaugeSignal SentimentSignal {
      get { return sentimentSignal_; }
      set {
        sentimentSignal_ = value;
      }
    }

    /// <summary>Field number for the "equilibrium_signal" field.</summary>
    public const int EquilibriumSignalFieldNumber = 10;
    private global::QuantGate.API.Proto.Stealth.GaugeSignal equilibriumSignal_ = 0;
    /// <summary>
    /// The signal tied to the equilibrium level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.GaugeSignal EquilibriumSignal {
      get { return equilibriumSignal_; }
      set {
        equilibriumSignal_ = value;
      }
    }

    /// <summary>Field number for the "sentiment_level" field.</summary>
    public const int SentimentLevelFieldNumber = 11;
    private uint sentimentLevel_;
    /// <summary>
    /// The normalized sentiment level ( 0=unset, else value=(x-1001)/1000 )
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint SentimentLevel {
      get { return sentimentLevel_; }
      set {
        sentimentLevel_ = value;
      }
    }

    /// <summary>Field number for the "equilibrium_level" field.</summary>
    public const int EquilibriumLevelFieldNumber = 12;
    private uint equilibriumLevel_;
    /// <summary>
    /// The normalized equilibrium level ( 0=unset, else value=(x-1001)/1000 )
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint EquilibriumLevel {
      get { return equilibriumLevel_; }
      set {
        equilibriumLevel_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StrategyUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StrategyUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Timestamp != other.Timestamp) return false;
      if (EntryProgress != other.EntryProgress) return false;
      if (ExitProgress != other.ExitProgress) return false;
      if (Signal != other.Signal) return false;
      if (PerceptionLevel != other.PerceptionLevel) return false;
      if (PerceptionSignal != other.PerceptionSignal) return false;
      if (CommitmentLevel != other.CommitmentLevel) return false;
      if (CommitmentSignal != other.CommitmentSignal) return false;
      if (SentimentSignal != other.SentimentSignal) return false;
      if (EquilibriumSignal != other.EquilibriumSignal) return false;
      if (SentimentLevel != other.SentimentLevel) return false;
      if (EquilibriumLevel != other.EquilibriumLevel) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Timestamp != 0UL) hash ^= Timestamp.GetHashCode();
      if (EntryProgress != 0) hash ^= EntryProgress.GetHashCode();
      if (ExitProgress != 0) hash ^= ExitProgress.GetHashCode();
      if (Signal != 0) hash ^= Signal.GetHashCode();
      if (PerceptionLevel != 0) hash ^= PerceptionLevel.GetHashCode();
      if (PerceptionSignal != 0) hash ^= PerceptionSignal.GetHashCode();
      if (CommitmentLevel != 0) hash ^= CommitmentLevel.GetHashCode();
      if (CommitmentSignal != 0) hash ^= CommitmentSignal.GetHashCode();
      if (SentimentSignal != 0) hash ^= SentimentSignal.GetHashCode();
      if (EquilibriumSignal != 0) hash ^= EquilibriumSignal.GetHashCode();
      if (SentimentLevel != 0) hash ^= SentimentLevel.GetHashCode();
      if (EquilibriumLevel != 0) hash ^= EquilibriumLevel.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Timestamp != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Timestamp);
      }
      if (EntryProgress != 0) {
        output.WriteRawTag(16);
        output.WriteSInt32(EntryProgress);
      }
      if (ExitProgress != 0) {
        output.WriteRawTag(24);
        output.WriteSInt32(ExitProgress);
      }
      if (Signal != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Signal);
      }
      if (PerceptionLevel != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(PerceptionLevel);
      }
      if (PerceptionSignal != 0) {
        output.WriteRawTag(48);
        output.WriteEnum((int) PerceptionSignal);
      }
      if (CommitmentLevel != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(CommitmentLevel);
      }
      if (CommitmentSignal != 0) {
        output.WriteRawTag(64);
        output.WriteEnum((int) CommitmentSignal);
      }
      if (SentimentSignal != 0) {
        output.WriteRawTag(72);
        output.WriteEnum((int) SentimentSignal);
      }
      if (EquilibriumSignal != 0) {
        output.WriteRawTag(80);
        output.WriteEnum((int) EquilibriumSignal);
      }
      if (SentimentLevel != 0) {
        output.WriteRawTag(88);
        output.WriteUInt32(SentimentLevel);
      }
      if (EquilibriumLevel != 0) {
        output.WriteRawTag(96);
        output.WriteUInt32(EquilibriumLevel);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Timestamp != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (EntryProgress != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(EntryProgress);
      }
      if (ExitProgress != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(ExitProgress);
      }
      if (Signal != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Signal);
      }
      if (PerceptionLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PerceptionLevel);
      }
      if (PerceptionSignal != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PerceptionSignal);
      }
      if (CommitmentLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CommitmentLevel);
      }
      if (CommitmentSignal != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CommitmentSignal);
      }
      if (SentimentSignal != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SentimentSignal);
      }
      if (EquilibriumSignal != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) EquilibriumSignal);
      }
      if (SentimentLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SentimentLevel);
      }
      if (EquilibriumLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(EquilibriumLevel);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StrategyUpdate other) {
      if (other == null) {
        return;
      }
      if (other.Timestamp != 0UL) {
        Timestamp = other.Timestamp;
      }
      if (other.EntryProgress != 0) {
        EntryProgress = other.EntryProgress;
      }
      if (other.ExitProgress != 0) {
        ExitProgress = other.ExitProgress;
      }
      if (other.Signal != 0) {
        Signal = other.Signal;
      }
      if (other.PerceptionLevel != 0) {
        PerceptionLevel = other.PerceptionLevel;
      }
      if (other.PerceptionSignal != 0) {
        PerceptionSignal = other.PerceptionSignal;
      }
      if (other.CommitmentLevel != 0) {
        CommitmentLevel = other.CommitmentLevel;
      }
      if (other.CommitmentSignal != 0) {
        CommitmentSignal = other.CommitmentSignal;
      }
      if (other.SentimentSignal != 0) {
        SentimentSignal = other.SentimentSignal;
      }
      if (other.EquilibriumSignal != 0) {
        EquilibriumSignal = other.EquilibriumSignal;
      }
      if (other.SentimentLevel != 0) {
        SentimentLevel = other.SentimentLevel;
      }
      if (other.EquilibriumLevel != 0) {
        EquilibriumLevel = other.EquilibriumLevel;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 16: {
            EntryProgress = input.ReadSInt32();
            break;
          }
          case 24: {
            ExitProgress = input.ReadSInt32();
            break;
          }
          case 32: {
            signal_ = (global::QuantGate.API.Proto.Stealth.StrategySignal) input.ReadEnum();
            break;
          }
          case 40: {
            PerceptionLevel = input.ReadUInt32();
            break;
          }
          case 48: {
            perceptionSignal_ = (global::QuantGate.API.Proto.Stealth.GaugeSignal) input.ReadEnum();
            break;
          }
          case 56: {
            CommitmentLevel = input.ReadUInt32();
            break;
          }
          case 64: {
            commitmentSignal_ = (global::QuantGate.API.Proto.Stealth.GaugeSignal) input.ReadEnum();
            break;
          }
          case 72: {
            sentimentSignal_ = (global::QuantGate.API.Proto.Stealth.GaugeSignal) input.ReadEnum();
            break;
          }
          case 80: {
            equilibriumSignal_ = (global::QuantGate.API.Proto.Stealth.GaugeSignal) input.ReadEnum();
            break;
          }
          case 88: {
            SentimentLevel = input.ReadUInt32();
            break;
          }
          case 96: {
            EquilibriumLevel = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// SinglePriceUpdate represents a new subscription update for a guage that returns a single 
  /// price result (such as Simple Moving Average).
  /// All prices are converted to long values, empty values will be decoded as NaN. 
  /// </summary>
  internal sealed partial class SinglePriceUpdate : pb::IMessage<SinglePriceUpdate> {
    private static readonly pb::MessageParser<SinglePriceUpdate> _parser = new pb::MessageParser<SinglePriceUpdate>(() => new SinglePriceUpdate());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SinglePriceUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SinglePriceUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SinglePriceUpdate(SinglePriceUpdate other) : this() {
      timestamp_ = other.timestamp_;
      value_ = other.value_;
      isDirty_ = other.isDirty_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SinglePriceUpdate Clone() {
      return new SinglePriceUpdate(this);
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 1;
    private ulong timestamp_;
    /// <summary>
    /// The timestamp of the latest update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private ulong value_;
    /// <summary>
    /// The single price value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Value {
      get { return value_; }
      set {
        value_ = value;
      }
    }

    /// <summary>Field number for the "is_dirty" field.</summary>
    public const int IsDirtyFieldNumber = 3;
    private bool isDirty_;
    /// <summary>
    /// Is the data that generated this potentially dirty (or stale)?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsDirty {
      get { return isDirty_; }
      set {
        isDirty_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SinglePriceUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SinglePriceUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Timestamp != other.Timestamp) return false;
      if (Value != other.Value) return false;
      if (IsDirty != other.IsDirty) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Timestamp != 0UL) hash ^= Timestamp.GetHashCode();
      if (Value != 0UL) hash ^= Value.GetHashCode();
      if (IsDirty != false) hash ^= IsDirty.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Timestamp != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Timestamp);
      }
      if (Value != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(Value);
      }
      if (IsDirty != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsDirty);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Timestamp != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (Value != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Value);
      }
      if (IsDirty != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SinglePriceUpdate other) {
      if (other == null) {
        return;
      }
      if (other.Timestamp != 0UL) {
        Timestamp = other.Timestamp;
      }
      if (other.Value != 0UL) {
        Value = other.Value;
      }
      if (other.IsDirty != false) {
        IsDirty = other.IsDirty;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 16: {
            Value = input.ReadUInt64();
            break;
          }
          case 24: {
            IsDirty = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Holds a single tick range for an Instrument definition. 
  /// </summary>
  internal sealed partial class TickValue : pb::IMessage<TickValue> {
    private static readonly pb::MessageParser<TickValue> _parser = new pb::MessageParser<TickValue>(() => new TickValue());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TickValue> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TickValue() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TickValue(TickValue other) : this() {
      start_ = other.start_;
      tick_ = other.tick_;
      denominator_ = other.denominator_;
      decimals_ = other.decimals_;
      format_ = other.format_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TickValue Clone() {
      return new TickValue(this);
    }

    /// <summary>Field number for the "start" field.</summary>
    public const int StartFieldNumber = 1;
    private double start_;
    /// <summary>
    /// The start of the tick range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Start {
      get { return start_; }
      set {
        start_ = value;
      }
    }

    /// <summary>Field number for the "tick" field.</summary>
    public const int TickFieldNumber = 2;
    private double tick_;
    /// <summary>
    /// The tick value at this range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Tick {
      get { return tick_; }
      set {
        tick_ = value;
      }
    }

    /// <summary>Field number for the "denominator" field.</summary>
    public const int DenominatorFieldNumber = 3;
    private uint denominator_;
    /// <summary>
    /// Denominator for fractional formats.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Denominator {
      get { return denominator_; }
      set {
        denominator_ = value;
      }
    }

    /// <summary>Field number for the "decimals" field.</summary>
    public const int DecimalsFieldNumber = 4;
    private int decimals_;
    /// <summary>
    /// Number of decimals in decimal format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Decimals {
      get { return decimals_; }
      set {
        decimals_ = value;
      }
    }

    /// <summary>Field number for the "format" field.</summary>
    public const int FormatFieldNumber = 5;
    private global::QuantGate.API.Proto.Stealth.TickValue.Types.TickFormat format_ = 0;
    /// <summary>
    /// Format to use (Decimal/Fraction/Tick).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.TickValue.Types.TickFormat Format {
      get { return format_; }
      set {
        format_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TickValue);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TickValue other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Start != other.Start) return false;
      if (Tick != other.Tick) return false;
      if (Denominator != other.Denominator) return false;
      if (Decimals != other.Decimals) return false;
      if (Format != other.Format) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Start != 0D) hash ^= Start.GetHashCode();
      if (Tick != 0D) hash ^= Tick.GetHashCode();
      if (Denominator != 0) hash ^= Denominator.GetHashCode();
      if (Decimals != 0) hash ^= Decimals.GetHashCode();
      if (Format != 0) hash ^= Format.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Start != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(Start);
      }
      if (Tick != 0D) {
        output.WriteRawTag(17);
        output.WriteDouble(Tick);
      }
      if (Denominator != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Denominator);
      }
      if (Decimals != 0) {
        output.WriteRawTag(32);
        output.WriteSInt32(Decimals);
      }
      if (Format != 0) {
        output.WriteRawTag(40);
        output.WriteEnum((int) Format);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Start != 0D) {
        size += 1 + 8;
      }
      if (Tick != 0D) {
        size += 1 + 8;
      }
      if (Denominator != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Denominator);
      }
      if (Decimals != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Decimals);
      }
      if (Format != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Format);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TickValue other) {
      if (other == null) {
        return;
      }
      if (other.Start != 0D) {
        Start = other.Start;
      }
      if (other.Tick != 0D) {
        Tick = other.Tick;
      }
      if (other.Denominator != 0) {
        Denominator = other.Denominator;
      }
      if (other.Decimals != 0) {
        Decimals = other.Decimals;
      }
      if (other.Format != 0) {
        Format = other.Format;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            Start = input.ReadDouble();
            break;
          }
          case 17: {
            Tick = input.ReadDouble();
            break;
          }
          case 24: {
            Denominator = input.ReadUInt32();
            break;
          }
          case 32: {
            Decimals = input.ReadSInt32();
            break;
          }
          case 40: {
            format_ = (global::QuantGate.API.Proto.Stealth.TickValue.Types.TickFormat) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TickValue message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Types of tick formats available to display prices in.
      /// </summary>
      internal enum TickFormat {
        /// <summary>
        /// Decimal display (regular 0.000, etc.) 
        /// </summary>
        [pbr::OriginalName("Decimal")] Decimal = 0,
        /// <summary>
        /// Fractional format, such as 34 1/4.
        /// In this case, the denominator that will be used for non-integer portions of the
        /// number will be that supplied with the format. Note, that the fraction is generally 
        /// displayed in its simplified format (divide numerator and denominator by GCD). 
        /// </summary>
        [pbr::OriginalName("Fraction")] Fraction = 1,
        /// <summary>
        /// Tick format, such as 34'120.
        /// In this case, the value after the tick is the non-integer portion of the number,
        /// multiplied by the denominator value supplied, zero padded to the left to fit the
        /// number of digits required to display the denominator value as a full integer. 
        /// </summary>
        [pbr::OriginalName("Tick")] Tick = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Holds information about the current trading session for an instrument. 
  /// </summary>
  internal sealed partial class TradingSession : pb::IMessage<TradingSession> {
    private static readonly pb::MessageParser<TradingSession> _parser = new pb::MessageParser<TradingSession>(() => new TradingSession());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TradingSession> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradingSession() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradingSession(TradingSession other) : this() {
      close_ = other.close_;
      length_ = other.length_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TradingSession Clone() {
      return new TradingSession(this);
    }

    /// <summary>Field number for the "close" field.</summary>
    public const int CloseFieldNumber = 1;
    private int close_;
    /// <summary>
    /// The close time of the trading session in minutes from midnight.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Close {
      get { return close_; }
      set {
        close_ = value;
      }
    }

    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 2;
    private int length_;
    /// <summary>
    /// The length of the trading session in minutes from midnight.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Length {
      get { return length_; }
      set {
        length_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TradingSession);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TradingSession other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Close != other.Close) return false;
      if (Length != other.Length) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Close != 0) hash ^= Close.GetHashCode();
      if (Length != 0) hash ^= Length.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Close != 0) {
        output.WriteRawTag(8);
        output.WriteSInt32(Close);
      }
      if (Length != 0) {
        output.WriteRawTag(16);
        output.WriteSInt32(Length);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Close != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Close);
      }
      if (Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Length);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TradingSession other) {
      if (other == null) {
        return;
      }
      if (other.Close != 0) {
        Close = other.Close;
      }
      if (other.Length != 0) {
        Length = other.Length;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Close = input.ReadSInt32();
            break;
          }
          case 16: {
            Length = input.ReadSInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Holds the details of a trading instrument. 
  /// </summary>
  internal sealed partial class InstrumentUpdate : pb::IMessage<InstrumentUpdate> {
    private static readonly pb::MessageParser<InstrumentUpdate> _parser = new pb::MessageParser<InstrumentUpdate>(() => new InstrumentUpdate());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<InstrumentUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstrumentUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstrumentUpdate(InstrumentUpdate other) : this() {
      symbol_ = other.symbol_;
      underlying_ = other.underlying_;
      currency_ = other.currency_;
      exchange_ = other.exchange_;
      instrumentType_ = other.instrumentType_;
      putOrCall_ = other.putOrCall_;
      strike_ = other.strike_;
      expiryDate_ = other.expiryDate_;
      multiplier_ = other.multiplier_;
      displayName_ = other.displayName_;
      timeZone_ = other.timeZone_;
      tickValues_ = other.tickValues_.Clone();
      tradingSessions_ = other.tradingSessions_.Clone();
      brokerSymbols_ = other.brokerSymbols_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstrumentUpdate Clone() {
      return new InstrumentUpdate(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    /// <summary>
    /// The symbol as listed by our servers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "underlying" field.</summary>
    public const int UnderlyingFieldNumber = 2;
    private string underlying_ = "";
    /// <summary>
    /// The underlying symbol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Underlying {
      get { return underlying_; }
      set {
        underlying_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "currency" field.</summary>
    public const int CurrencyFieldNumber = 3;
    private string currency_ = "";
    /// <summary>
    /// The currency the instrument is traded in.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Currency {
      get { return currency_; }
      set {
        currency_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "exchange" field.</summary>
    public const int ExchangeFieldNumber = 4;
    private string exchange_ = "";
    /// <summary>
    /// The exchange that the instrument is listed on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Exchange {
      get { return exchange_; }
      set {
        exchange_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "instrument_type" field.</summary>
    public const int InstrumentTypeFieldNumber = 5;
    private global::QuantGate.API.Proto.Stealth.InstrumentType instrumentType_ = 0;
    /// <summary>
    /// The type of instrument (CS, FUT, IDX, FX, CRY, etc.).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.InstrumentType InstrumentType {
      get { return instrumentType_; }
      set {
        instrumentType_ = value;
      }
    }

    /// <summary>Field number for the "put_or_call" field.</summary>
    public const int PutOrCallFieldNumber = 6;
    private global::QuantGate.API.Proto.Stealth.PutOrCall putOrCall_ = 0;
    /// <summary>
    /// "Right" of an option, if an option (empty otherwise).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.PutOrCall PutOrCall {
      get { return putOrCall_; }
      set {
        putOrCall_ = value;
      }
    }

    /// <summary>Field number for the "strike" field.</summary>
    public const int StrikeFieldNumber = 7;
    private double strike_;
    /// <summary>
    /// Strike price of an option, if an option (zero otherwise).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Strike {
      get { return strike_; }
      set {
        strike_ = value;
      }
    }

    /// <summary>Field number for the "expiry_date" field.</summary>
    public const int ExpiryDateFieldNumber = 8;
    private ulong expiryDate_;
    /// <summary>
    /// The expiry date of the instrument, if applicable (days from Jan 1, 1800).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong ExpiryDate {
      get { return expiryDate_; }
      set {
        expiryDate_ = value;
      }
    }

    /// <summary>Field number for the "multiplier" field.</summary>
    public const int MultiplierFieldNumber = 9;
    private double multiplier_;
    /// <summary>
    /// The price multiplier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Multiplier {
      get { return multiplier_; }
      set {
        multiplier_ = value;
      }
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 10;
    private string displayName_ = "";
    /// <summary>
    /// The display name of the instrument.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "time_zone" field.</summary>
    public const int TimeZoneFieldNumber = 11;
    private string timeZone_ = "";
    /// <summary>
    /// The time zone of the primary exchange the instrument is traded on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TimeZone {
      get { return timeZone_; }
      set {
        timeZone_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "tick_values" field.</summary>
    public const int TickValuesFieldNumber = 12;
    private static readonly pb::FieldCodec<global::QuantGate.API.Proto.Stealth.TickValue> _repeated_tickValues_codec
        = pb::FieldCodec.ForMessage(98, global::QuantGate.API.Proto.Stealth.TickValue.Parser);
    private readonly pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.TickValue> tickValues_ = new pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.TickValue>();
    /// <summary>
    /// The tick values used to determine price levels.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.TickValue> TickValues {
      get { return tickValues_; }
    }

    /// <summary>Field number for the "trading_sessions" field.</summary>
    public const int TradingSessionsFieldNumber = 13;
    private static readonly pb::FieldCodec<global::QuantGate.API.Proto.Stealth.TradingSession> _repeated_tradingSessions_codec
        = pb::FieldCodec.ForMessage(106, global::QuantGate.API.Proto.Stealth.TradingSession.Parser);
    private readonly pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.TradingSession> tradingSessions_ = new pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.TradingSession>();
    /// <summary>
    /// The trading session end times and lengths for each day Sun-Sat.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.TradingSession> TradingSessions {
      get { return tradingSessions_; }
    }

    /// <summary>Field number for the "broker_symbols" field.</summary>
    public const int BrokerSymbolsFieldNumber = 14;
    private static readonly pbc::MapField<string, string>.Codec _map_brokerSymbols_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 114);
    private readonly pbc::MapField<string, string> brokerSymbols_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Map of broker symbols according to broker (ib, cqg, dtniq, etc.).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> BrokerSymbols {
      get { return brokerSymbols_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as InstrumentUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(InstrumentUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (Underlying != other.Underlying) return false;
      if (Currency != other.Currency) return false;
      if (Exchange != other.Exchange) return false;
      if (InstrumentType != other.InstrumentType) return false;
      if (PutOrCall != other.PutOrCall) return false;
      if (Strike != other.Strike) return false;
      if (ExpiryDate != other.ExpiryDate) return false;
      if (Multiplier != other.Multiplier) return false;
      if (DisplayName != other.DisplayName) return false;
      if (TimeZone != other.TimeZone) return false;
      if(!tickValues_.Equals(other.tickValues_)) return false;
      if(!tradingSessions_.Equals(other.tradingSessions_)) return false;
      if (!BrokerSymbols.Equals(other.BrokerSymbols)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (Underlying.Length != 0) hash ^= Underlying.GetHashCode();
      if (Currency.Length != 0) hash ^= Currency.GetHashCode();
      if (Exchange.Length != 0) hash ^= Exchange.GetHashCode();
      if (InstrumentType != 0) hash ^= InstrumentType.GetHashCode();
      if (PutOrCall != 0) hash ^= PutOrCall.GetHashCode();
      if (Strike != 0D) hash ^= Strike.GetHashCode();
      if (ExpiryDate != 0UL) hash ^= ExpiryDate.GetHashCode();
      if (Multiplier != 0D) hash ^= Multiplier.GetHashCode();
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      if (TimeZone.Length != 0) hash ^= TimeZone.GetHashCode();
      hash ^= tickValues_.GetHashCode();
      hash ^= tradingSessions_.GetHashCode();
      hash ^= BrokerSymbols.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (Underlying.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Underlying);
      }
      if (Currency.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Currency);
      }
      if (Exchange.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Exchange);
      }
      if (InstrumentType != 0) {
        output.WriteRawTag(40);
        output.WriteEnum((int) InstrumentType);
      }
      if (PutOrCall != 0) {
        output.WriteRawTag(48);
        output.WriteEnum((int) PutOrCall);
      }
      if (Strike != 0D) {
        output.WriteRawTag(57);
        output.WriteDouble(Strike);
      }
      if (ExpiryDate != 0UL) {
        output.WriteRawTag(64);
        output.WriteUInt64(ExpiryDate);
      }
      if (Multiplier != 0D) {
        output.WriteRawTag(73);
        output.WriteDouble(Multiplier);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(DisplayName);
      }
      if (TimeZone.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(TimeZone);
      }
      tickValues_.WriteTo(output, _repeated_tickValues_codec);
      tradingSessions_.WriteTo(output, _repeated_tradingSessions_codec);
      brokerSymbols_.WriteTo(output, _map_brokerSymbols_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (Underlying.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Underlying);
      }
      if (Currency.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Currency);
      }
      if (Exchange.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Exchange);
      }
      if (InstrumentType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) InstrumentType);
      }
      if (PutOrCall != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PutOrCall);
      }
      if (Strike != 0D) {
        size += 1 + 8;
      }
      if (ExpiryDate != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(ExpiryDate);
      }
      if (Multiplier != 0D) {
        size += 1 + 8;
      }
      if (DisplayName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      if (TimeZone.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TimeZone);
      }
      size += tickValues_.CalculateSize(_repeated_tickValues_codec);
      size += tradingSessions_.CalculateSize(_repeated_tradingSessions_codec);
      size += brokerSymbols_.CalculateSize(_map_brokerSymbols_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(InstrumentUpdate other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.Underlying.Length != 0) {
        Underlying = other.Underlying;
      }
      if (other.Currency.Length != 0) {
        Currency = other.Currency;
      }
      if (other.Exchange.Length != 0) {
        Exchange = other.Exchange;
      }
      if (other.InstrumentType != 0) {
        InstrumentType = other.InstrumentType;
      }
      if (other.PutOrCall != 0) {
        PutOrCall = other.PutOrCall;
      }
      if (other.Strike != 0D) {
        Strike = other.Strike;
      }
      if (other.ExpiryDate != 0UL) {
        ExpiryDate = other.ExpiryDate;
      }
      if (other.Multiplier != 0D) {
        Multiplier = other.Multiplier;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
      if (other.TimeZone.Length != 0) {
        TimeZone = other.TimeZone;
      }
      tickValues_.Add(other.tickValues_);
      tradingSessions_.Add(other.tradingSessions_);
      brokerSymbols_.Add(other.brokerSymbols_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            Underlying = input.ReadString();
            break;
          }
          case 26: {
            Currency = input.ReadString();
            break;
          }
          case 34: {
            Exchange = input.ReadString();
            break;
          }
          case 40: {
            instrumentType_ = (global::QuantGate.API.Proto.Stealth.InstrumentType) input.ReadEnum();
            break;
          }
          case 48: {
            putOrCall_ = (global::QuantGate.API.Proto.Stealth.PutOrCall) input.ReadEnum();
            break;
          }
          case 57: {
            Strike = input.ReadDouble();
            break;
          }
          case 64: {
            ExpiryDate = input.ReadUInt64();
            break;
          }
          case 73: {
            Multiplier = input.ReadDouble();
            break;
          }
          case 82: {
            DisplayName = input.ReadString();
            break;
          }
          case 90: {
            TimeZone = input.ReadString();
            break;
          }
          case 98: {
            tickValues_.AddEntriesFrom(input, _repeated_tickValues_codec);
            break;
          }
          case 106: {
            tradingSessions_.AddEntriesFrom(input, _repeated_tradingSessions_codec);
            break;
          }
          case 114: {
            brokerSymbols_.AddEntriesFrom(input, _map_brokerSymbols_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Holds basic information for an individual symbol within a symbol search result. 
  /// </summary>
  internal sealed partial class SymbolSearchResult : pb::IMessage<SymbolSearchResult> {
    private static readonly pb::MessageParser<SymbolSearchResult> _parser = new pb::MessageParser<SymbolSearchResult>(() => new SymbolSearchResult());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SymbolSearchResult> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolSearchResult() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolSearchResult(SymbolSearchResult other) : this() {
      symbol_ = other.symbol_;
      underlying_ = other.underlying_;
      currency_ = other.currency_;
      instrumentType_ = other.instrumentType_;
      exchange_ = other.exchange_;
      displayName_ = other.displayName_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolSearchResult Clone() {
      return new SymbolSearchResult(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    /// <summary>
    /// The symbol as listed by our servers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "underlying" field.</summary>
    public const int UnderlyingFieldNumber = 2;
    private string underlying_ = "";
    /// <summary>
    /// The underlying symbol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Underlying {
      get { return underlying_; }
      set {
        underlying_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "currency" field.</summary>
    public const int CurrencyFieldNumber = 3;
    private string currency_ = "";
    /// <summary>
    /// The currency the instrument is traded in.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Currency {
      get { return currency_; }
      set {
        currency_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "instrument_type" field.</summary>
    public const int InstrumentTypeFieldNumber = 4;
    private global::QuantGate.API.Proto.Stealth.InstrumentType instrumentType_ = 0;
    /// <summary>
    /// The type of instrument (CS, FUT, IDX, FX, CRY, etc.).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.InstrumentType InstrumentType {
      get { return instrumentType_; }
      set {
        instrumentType_ = value;
      }
    }

    /// <summary>Field number for the "exchange" field.</summary>
    public const int ExchangeFieldNumber = 5;
    private string exchange_ = "";
    /// <summary>
    /// The primary exchange (MIC) the instrument is traded on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Exchange {
      get { return exchange_; }
      set {
        exchange_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 6;
    private string displayName_ = "";
    /// <summary>
    /// The display name of the instrument.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SymbolSearchResult);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SymbolSearchResult other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (Underlying != other.Underlying) return false;
      if (Currency != other.Currency) return false;
      if (InstrumentType != other.InstrumentType) return false;
      if (Exchange != other.Exchange) return false;
      if (DisplayName != other.DisplayName) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (Underlying.Length != 0) hash ^= Underlying.GetHashCode();
      if (Currency.Length != 0) hash ^= Currency.GetHashCode();
      if (InstrumentType != 0) hash ^= InstrumentType.GetHashCode();
      if (Exchange.Length != 0) hash ^= Exchange.GetHashCode();
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (Underlying.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Underlying);
      }
      if (Currency.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Currency);
      }
      if (InstrumentType != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) InstrumentType);
      }
      if (Exchange.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Exchange);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(DisplayName);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (Underlying.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Underlying);
      }
      if (Currency.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Currency);
      }
      if (InstrumentType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) InstrumentType);
      }
      if (Exchange.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Exchange);
      }
      if (DisplayName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SymbolSearchResult other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.Underlying.Length != 0) {
        Underlying = other.Underlying;
      }
      if (other.Currency.Length != 0) {
        Currency = other.Currency;
      }
      if (other.InstrumentType != 0) {
        InstrumentType = other.InstrumentType;
      }
      if (other.Exchange.Length != 0) {
        Exchange = other.Exchange;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            Underlying = input.ReadString();
            break;
          }
          case 26: {
            Currency = input.ReadString();
            break;
          }
          case 32: {
            instrumentType_ = (global::QuantGate.API.Proto.Stealth.InstrumentType) input.ReadEnum();
            break;
          }
          case 42: {
            Exchange = input.ReadString();
            break;
          }
          case 50: {
            DisplayName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Holds the results of a symbol search request within a symbol search subscription.
  /// Note: The user must subscribe to a definition/search subscription to get results 
  ///       and make specific requests using a definition/search/{term} send message. 
  /// </summary>
  internal sealed partial class SymbolSearchUpdate : pb::IMessage<SymbolSearchUpdate> {
    private static readonly pb::MessageParser<SymbolSearchUpdate> _parser = new pb::MessageParser<SymbolSearchUpdate>(() => new SymbolSearchUpdate());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SymbolSearchUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolSearchUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolSearchUpdate(SymbolSearchUpdate other) : this() {
      searchTerm_ = other.searchTerm_;
      results_ = other.results_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SymbolSearchUpdate Clone() {
      return new SymbolSearchUpdate(this);
    }

    /// <summary>Field number for the "search_term" field.</summary>
    public const int SearchTermFieldNumber = 1;
    private string searchTerm_ = "";
    /// <summary>
    /// The search term the results are for.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SearchTerm {
      get { return searchTerm_; }
      set {
        searchTerm_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "results" field.</summary>
    public const int ResultsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::QuantGate.API.Proto.Stealth.SymbolSearchResult> _repeated_results_codec
        = pb::FieldCodec.ForMessage(18, global::QuantGate.API.Proto.Stealth.SymbolSearchResult.Parser);
    private readonly pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.SymbolSearchResult> results_ = new pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.SymbolSearchResult>();
    /// <summary>
    /// The search results.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.SymbolSearchResult> Results {
      get { return results_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SymbolSearchUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SymbolSearchUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SearchTerm != other.SearchTerm) return false;
      if(!results_.Equals(other.results_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (SearchTerm.Length != 0) hash ^= SearchTerm.GetHashCode();
      hash ^= results_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (SearchTerm.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(SearchTerm);
      }
      results_.WriteTo(output, _repeated_results_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (SearchTerm.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SearchTerm);
      }
      size += results_.CalculateSize(_repeated_results_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SymbolSearchUpdate other) {
      if (other == null) {
        return;
      }
      if (other.SearchTerm.Length != 0) {
        SearchTerm = other.SearchTerm;
      }
      results_.Add(other.results_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            SearchTerm = input.ReadString();
            break;
          }
          case 18: {
            results_.AddEntriesFrom(input, _repeated_results_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Holds basic information for an individual symbol within a top symbols update. 
  /// </summary>
  internal sealed partial class TopSymbolItem : pb::IMessage<TopSymbolItem> {
    private static readonly pb::MessageParser<TopSymbolItem> _parser = new pb::MessageParser<TopSymbolItem>(() => new TopSymbolItem());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TopSymbolItem> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TopSymbolItem() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TopSymbolItem(TopSymbolItem other) : this() {
      timestamp_ = other.timestamp_;
      symbol_ = other.symbol_;
      underlying_ = other.underlying_;
      currency_ = other.currency_;
      instrumentType_ = other.instrumentType_;
      exchange_ = other.exchange_;
      displayName_ = other.displayName_;
      entryProgress_ = other.entryProgress_;
      signal_ = other.signal_;
      perceptionSignal_ = other.perceptionSignal_;
      commitmentSignal_ = other.commitmentSignal_;
      sentimentSignal_ = other.sentimentSignal_;
      equilibriumSignal_ = other.equilibriumSignal_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TopSymbolItem Clone() {
      return new TopSymbolItem(this);
    }

    /// <summary>Field number for the "timestamp" field.</summary>
    public const int TimestampFieldNumber = 1;
    private ulong timestamp_;
    /// <summary>
    /// The timestamp of the latest update.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Timestamp {
      get { return timestamp_; }
      set {
        timestamp_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    /// <summary>
    /// The symbol as listed by our servers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "underlying" field.</summary>
    public const int UnderlyingFieldNumber = 3;
    private string underlying_ = "";
    /// <summary>
    /// The underlying symbol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Underlying {
      get { return underlying_; }
      set {
        underlying_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "currency" field.</summary>
    public const int CurrencyFieldNumber = 4;
    private string currency_ = "";
    /// <summary>
    /// The currency the instrument is traded in.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Currency {
      get { return currency_; }
      set {
        currency_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "instrument_type" field.</summary>
    public const int InstrumentTypeFieldNumber = 5;
    private global::QuantGate.API.Proto.Stealth.InstrumentType instrumentType_ = 0;
    /// <summary>
    /// The type of instrument (CS, FUT, IDX, FX, CRY, etc.).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.InstrumentType InstrumentType {
      get { return instrumentType_; }
      set {
        instrumentType_ = value;
      }
    }

    /// <summary>Field number for the "exchange" field.</summary>
    public const int ExchangeFieldNumber = 6;
    private string exchange_ = "";
    /// <summary>
    /// The primary exchange (MIC) the instrument is traded on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Exchange {
      get { return exchange_; }
      set {
        exchange_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "display_name" field.</summary>
    public const int DisplayNameFieldNumber = 7;
    private string displayName_ = "";
    /// <summary>
    /// The display name of the instrument.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DisplayName {
      get { return displayName_; }
      set {
        displayName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "entry_progress" field.</summary>
    public const int EntryProgressFieldNumber = 8;
    private int entryProgress_;
    /// <summary>
    /// The entry progress value. (-1000 to 1000)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int EntryProgress {
      get { return entryProgress_; }
      set {
        entryProgress_ = value;
      }
    }

    /// <summary>Field number for the "signal" field.</summary>
    public const int SignalFieldNumber = 9;
    private global::QuantGate.API.Proto.Stealth.StrategySignal signal_ = 0;
    /// <summary>
    /// The entry signal for the strategy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.StrategySignal Signal {
      get { return signal_; }
      set {
        signal_ = value;
      }
    }

    /// <summary>Field number for the "perception_signal" field.</summary>
    public const int PerceptionSignalFieldNumber = 10;
    private global::QuantGate.API.Proto.Stealth.GaugeSignal perceptionSignal_ = 0;
    /// <summary>
    /// The signal tied to the perception level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.GaugeSignal PerceptionSignal {
      get { return perceptionSignal_; }
      set {
        perceptionSignal_ = value;
      }
    }

    /// <summary>Field number for the "commitment_signal" field.</summary>
    public const int CommitmentSignalFieldNumber = 11;
    private global::QuantGate.API.Proto.Stealth.GaugeSignal commitmentSignal_ = 0;
    /// <summary>
    /// The signal tied to the commitment level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.GaugeSignal CommitmentSignal {
      get { return commitmentSignal_; }
      set {
        commitmentSignal_ = value;
      }
    }

    /// <summary>Field number for the "sentiment_signal" field.</summary>
    public const int SentimentSignalFieldNumber = 12;
    private global::QuantGate.API.Proto.Stealth.GaugeSignal sentimentSignal_ = 0;
    /// <summary>
    /// The signal tied to the 50t sentiment indication.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.GaugeSignal SentimentSignal {
      get { return sentimentSignal_; }
      set {
        sentimentSignal_ = value;
      }
    }

    /// <summary>Field number for the "equilibrium_signal" field.</summary>
    public const int EquilibriumSignalFieldNumber = 13;
    private global::QuantGate.API.Proto.Stealth.GaugeSignal equilibriumSignal_ = 0;
    /// <summary>
    /// The signal tied to the equilibrium level.    
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::QuantGate.API.Proto.Stealth.GaugeSignal EquilibriumSignal {
      get { return equilibriumSignal_; }
      set {
        equilibriumSignal_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TopSymbolItem);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TopSymbolItem other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Timestamp != other.Timestamp) return false;
      if (Symbol != other.Symbol) return false;
      if (Underlying != other.Underlying) return false;
      if (Currency != other.Currency) return false;
      if (InstrumentType != other.InstrumentType) return false;
      if (Exchange != other.Exchange) return false;
      if (DisplayName != other.DisplayName) return false;
      if (EntryProgress != other.EntryProgress) return false;
      if (Signal != other.Signal) return false;
      if (PerceptionSignal != other.PerceptionSignal) return false;
      if (CommitmentSignal != other.CommitmentSignal) return false;
      if (SentimentSignal != other.SentimentSignal) return false;
      if (EquilibriumSignal != other.EquilibriumSignal) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Timestamp != 0UL) hash ^= Timestamp.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (Underlying.Length != 0) hash ^= Underlying.GetHashCode();
      if (Currency.Length != 0) hash ^= Currency.GetHashCode();
      if (InstrumentType != 0) hash ^= InstrumentType.GetHashCode();
      if (Exchange.Length != 0) hash ^= Exchange.GetHashCode();
      if (DisplayName.Length != 0) hash ^= DisplayName.GetHashCode();
      if (EntryProgress != 0) hash ^= EntryProgress.GetHashCode();
      if (Signal != 0) hash ^= Signal.GetHashCode();
      if (PerceptionSignal != 0) hash ^= PerceptionSignal.GetHashCode();
      if (CommitmentSignal != 0) hash ^= CommitmentSignal.GetHashCode();
      if (SentimentSignal != 0) hash ^= SentimentSignal.GetHashCode();
      if (EquilibriumSignal != 0) hash ^= EquilibriumSignal.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Timestamp != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Timestamp);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (Underlying.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Underlying);
      }
      if (Currency.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Currency);
      }
      if (InstrumentType != 0) {
        output.WriteRawTag(40);
        output.WriteEnum((int) InstrumentType);
      }
      if (Exchange.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Exchange);
      }
      if (DisplayName.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(DisplayName);
      }
      if (EntryProgress != 0) {
        output.WriteRawTag(64);
        output.WriteSInt32(EntryProgress);
      }
      if (Signal != 0) {
        output.WriteRawTag(72);
        output.WriteEnum((int) Signal);
      }
      if (PerceptionSignal != 0) {
        output.WriteRawTag(80);
        output.WriteEnum((int) PerceptionSignal);
      }
      if (CommitmentSignal != 0) {
        output.WriteRawTag(88);
        output.WriteEnum((int) CommitmentSignal);
      }
      if (SentimentSignal != 0) {
        output.WriteRawTag(96);
        output.WriteEnum((int) SentimentSignal);
      }
      if (EquilibriumSignal != 0) {
        output.WriteRawTag(104);
        output.WriteEnum((int) EquilibriumSignal);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Timestamp != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Timestamp);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (Underlying.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Underlying);
      }
      if (Currency.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Currency);
      }
      if (InstrumentType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) InstrumentType);
      }
      if (Exchange.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Exchange);
      }
      if (DisplayName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisplayName);
      }
      if (EntryProgress != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(EntryProgress);
      }
      if (Signal != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Signal);
      }
      if (PerceptionSignal != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PerceptionSignal);
      }
      if (CommitmentSignal != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CommitmentSignal);
      }
      if (SentimentSignal != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SentimentSignal);
      }
      if (EquilibriumSignal != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) EquilibriumSignal);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TopSymbolItem other) {
      if (other == null) {
        return;
      }
      if (other.Timestamp != 0UL) {
        Timestamp = other.Timestamp;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.Underlying.Length != 0) {
        Underlying = other.Underlying;
      }
      if (other.Currency.Length != 0) {
        Currency = other.Currency;
      }
      if (other.InstrumentType != 0) {
        InstrumentType = other.InstrumentType;
      }
      if (other.Exchange.Length != 0) {
        Exchange = other.Exchange;
      }
      if (other.DisplayName.Length != 0) {
        DisplayName = other.DisplayName;
      }
      if (other.EntryProgress != 0) {
        EntryProgress = other.EntryProgress;
      }
      if (other.Signal != 0) {
        Signal = other.Signal;
      }
      if (other.PerceptionSignal != 0) {
        PerceptionSignal = other.PerceptionSignal;
      }
      if (other.CommitmentSignal != 0) {
        CommitmentSignal = other.CommitmentSignal;
      }
      if (other.SentimentSignal != 0) {
        SentimentSignal = other.SentimentSignal;
      }
      if (other.EquilibriumSignal != 0) {
        EquilibriumSignal = other.EquilibriumSignal;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            Timestamp = input.ReadUInt64();
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 26: {
            Underlying = input.ReadString();
            break;
          }
          case 34: {
            Currency = input.ReadString();
            break;
          }
          case 40: {
            instrumentType_ = (global::QuantGate.API.Proto.Stealth.InstrumentType) input.ReadEnum();
            break;
          }
          case 50: {
            Exchange = input.ReadString();
            break;
          }
          case 58: {
            DisplayName = input.ReadString();
            break;
          }
          case 64: {
            EntryProgress = input.ReadSInt32();
            break;
          }
          case 72: {
            signal_ = (global::QuantGate.API.Proto.Stealth.StrategySignal) input.ReadEnum();
            break;
          }
          case 80: {
            perceptionSignal_ = (global::QuantGate.API.Proto.Stealth.GaugeSignal) input.ReadEnum();
            break;
          }
          case 88: {
            commitmentSignal_ = (global::QuantGate.API.Proto.Stealth.GaugeSignal) input.ReadEnum();
            break;
          }
          case 96: {
            sentimentSignal_ = (global::QuantGate.API.Proto.Stealth.GaugeSignal) input.ReadEnum();
            break;
          }
          case 104: {
            equilibriumSignal_ = (global::QuantGate.API.Proto.Stealth.GaugeSignal) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Holds an update of the current top items of a top symbols subscription. 
  /// </summary>
  internal sealed partial class TopSymbolsUpdate : pb::IMessage<TopSymbolsUpdate> {
    private static readonly pb::MessageParser<TopSymbolsUpdate> _parser = new pb::MessageParser<TopSymbolsUpdate>(() => new TopSymbolsUpdate());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TopSymbolsUpdate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::QuantGate.API.Proto.Stealth.StealthApiV20Reflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TopSymbolsUpdate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TopSymbolsUpdate(TopSymbolsUpdate other) : this() {
      symbols_ = other.symbols_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TopSymbolsUpdate Clone() {
      return new TopSymbolsUpdate(this);
    }

    /// <summary>Field number for the "symbols" field.</summary>
    public const int SymbolsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::QuantGate.API.Proto.Stealth.TopSymbolItem> _repeated_symbols_codec
        = pb::FieldCodec.ForMessage(10, global::QuantGate.API.Proto.Stealth.TopSymbolItem.Parser);
    private readonly pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.TopSymbolItem> symbols_ = new pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.TopSymbolItem>();
    /// <summary>
    /// The top symbol results;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::QuantGate.API.Proto.Stealth.TopSymbolItem> Symbols {
      get { return symbols_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TopSymbolsUpdate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TopSymbolsUpdate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!symbols_.Equals(other.symbols_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= symbols_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      symbols_.WriteTo(output, _repeated_symbols_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += symbols_.CalculateSize(_repeated_symbols_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TopSymbolsUpdate other) {
      if (other == null) {
        return;
      }
      symbols_.Add(other.symbols_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            symbols_.AddEntriesFrom(input, _repeated_symbols_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
